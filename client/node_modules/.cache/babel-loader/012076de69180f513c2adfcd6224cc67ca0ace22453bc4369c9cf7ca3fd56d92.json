{"ast":null,"code":"var debug = require('debug')('nodemon');\nvar fs = require('fs');\nvar path = require('path');\nvar exists = fs.exists || path.exists;\nvar utils = require('../utils');\nvar rules = require('../rules');\nvar parse = require('../rules/parse');\nvar exec = require('./exec');\nvar defaults = require('./defaults');\nmodule.exports = load;\nmodule.exports.mutateExecOptions = mutateExecOptions;\nvar existsSync = fs.existsSync || path.existsSync;\nfunction findAppScript() {\n  // nodemon has been run alone, so try to read the package file\n  // or try to read the index.js file\n\n  var pkg = existsSync(path.join(process.cwd(), 'package.json')) && require(path.join(process.cwd(), 'package.json'));\n  if ((!pkg || pkg.main == undefined) && existsSync('./index.js')) {\n    return 'index.js';\n  }\n}\n\n/**\n * Load the nodemon config, first reading the global root/nodemon.json, then\n * the local nodemon.json to the exec and then overwriting using any user\n * specified settings (i.e. from the cli)\n *\n * @param  {Object} settings user defined settings\n * @param  {Function} ready    callback that receives complete config\n */\nfunction load(settings, options, config, callback) {\n  config.loaded = [];\n  // first load the root nodemon.json\n  loadFile(options, config, utils.home, function (options) {\n    // then load the user's local configuration file\n    if (settings.configFile) {\n      options.configFile = path.resolve(settings.configFile);\n    }\n    loadFile(options, config, process.cwd(), function (options) {\n      // Then merge over with the user settings (parsed from the cli).\n      // Note that merge protects and favours existing values over new values,\n      // and thus command line arguments get priority\n      options = utils.merge(settings, options);\n\n      // legacy support\n      if (!Array.isArray(options.ignore)) {\n        options.ignore = [options.ignore];\n      }\n      if (!options.ignoreRoot) {\n        options.ignoreRoot = defaults.ignoreRoot;\n      }\n\n      // blend the user ignore and the default ignore together\n      if (options.ignoreRoot && options.ignore) {\n        if (!Array.isArray(options.ignoreRoot)) {\n          options.ignoreRoot = [options.ignoreRoot];\n        }\n        options.ignore = options.ignoreRoot.concat(options.ignore);\n      } else {\n        options.ignore = defaults.ignore.concat(options.ignore);\n      }\n\n      // add in any missing defaults\n      options = utils.merge(options, defaults);\n      if (!options.script && !options.exec) {\n        var found = findAppScript();\n        if (found) {\n          if (!options.args) {\n            options.args = [];\n          }\n          // if the script is found as a result of not being on the command\n          // line, then we move any of the pre double-dash args in execArgs\n          const n = options.scriptPosition === null ? options.args.length : options.scriptPosition;\n          options.execArgs = (options.execArgs || []).concat(options.args.splice(0, n));\n          options.scriptPosition = null;\n          options.script = found;\n        }\n      }\n      mutateExecOptions(options);\n      if (options.quiet) {\n        utils.quiet();\n      }\n      if (options.verbose) {\n        utils.debug = true;\n      }\n\n      // simplify the ready callback to be called after the rules are normalised\n      // from strings to regexp through the rules lib. Note that this gets\n      // created *after* options is overwritten twice in the lines above.\n      var ready = function (options) {\n        normaliseRules(options, callback);\n      };\n      ready(options);\n    });\n  });\n}\nfunction normaliseRules(options, ready) {\n  // convert ignore and watch options to rules/regexp\n  rules.watch.add(options.watch);\n  rules.ignore.add(options.ignore);\n\n  // normalise the watch and ignore arrays\n  options.watch = options.watch === false ? false : rules.rules.watch;\n  options.ignore = rules.rules.ignore;\n  ready(options);\n}\n\n/**\n * Looks for a config in the current working directory, and a config in the\n * user's home directory, merging the two together, giving priority to local\n * config. This can then be overwritten later by command line arguments\n *\n * @param  {Function} ready callback to pass loaded settings to\n */\nfunction loadFile(options, config, dir, ready) {\n  if (!ready) {\n    ready = function () {};\n  }\n  var callback = function (settings) {\n    // prefer the local nodemon.json and fill in missing items using\n    // the global options\n    ready(utils.merge(settings, options));\n  };\n  if (!dir) {\n    return callback({});\n  }\n  var filename = options.configFile || path.join(dir, 'nodemon.json');\n  if (config.loaded.indexOf(filename) !== -1) {\n    // don't bother re-parsing the same config file\n    return callback({});\n  }\n  fs.readFile(filename, 'utf8', function (err, data) {\n    if (err) {\n      if (err.code === 'ENOENT') {\n        if (!options.configFile && dir !== utils.home) {\n          // if no specified local config file and local nodemon.json\n          // doesn't exist, try the package.json\n          return loadPackageJSON(config, callback);\n        }\n      }\n      return callback({});\n    }\n    var settings = {};\n    try {\n      settings = JSON.parse(data.toString('utf8').replace(/^\\uFEFF/, ''));\n      if (!filename.endsWith('package.json') || settings.nodemonConfig) {\n        config.loaded.push(filename);\n      }\n    } catch (e) {\n      utils.log.fail('Failed to parse config ' + filename);\n      console.error(e);\n      process.exit(1);\n    }\n\n    // options values will overwrite settings\n    callback(settings);\n  });\n}\nfunction loadPackageJSON(config, ready) {\n  if (!ready) {\n    ready = () => {};\n  }\n  const dir = process.cwd();\n  const filename = path.join(dir, 'package.json');\n  const packageLoadOptions = {\n    configFile: filename\n  };\n  return loadFile(packageLoadOptions, config, dir, settings => {\n    ready(settings.nodemonConfig || {});\n  });\n}\nfunction mutateExecOptions(options) {\n  // work out the execOptions based on the final config we have\n  options.execOptions = exec({\n    script: options.script,\n    exec: options.exec,\n    args: options.args,\n    scriptPosition: options.scriptPosition,\n    nodeArgs: options.nodeArgs,\n    execArgs: options.execArgs,\n    ext: options.ext,\n    env: options.env\n  }, options.execMap);\n\n  // clean up values that we don't need at the top level\n  delete options.scriptPosition;\n  delete options.script;\n  delete options.args;\n  delete options.ext;\n  return options;\n}","map":{"version":3,"names":["debug","require","fs","path","exists","utils","rules","parse","exec","defaults","module","exports","load","mutateExecOptions","existsSync","findAppScript","pkg","join","process","cwd","main","undefined","settings","options","config","callback","loaded","loadFile","home","configFile","resolve","merge","Array","isArray","ignore","ignoreRoot","concat","script","found","args","n","scriptPosition","length","execArgs","splice","quiet","verbose","ready","normaliseRules","watch","add","dir","filename","indexOf","readFile","err","data","code","loadPackageJSON","JSON","toString","replace","endsWith","nodemonConfig","push","e","log","fail","console","error","exit","packageLoadOptions","execOptions","nodeArgs","ext","env","execMap"],"sources":["C:/Users/DELL/node_modules/nodemon/lib/config/load.js"],"sourcesContent":["var debug = require('debug')('nodemon');\nvar fs = require('fs');\nvar path = require('path');\nvar exists = fs.exists || path.exists;\nvar utils = require('../utils');\nvar rules = require('../rules');\nvar parse = require('../rules/parse');\nvar exec = require('./exec');\nvar defaults = require('./defaults');\n\nmodule.exports = load;\nmodule.exports.mutateExecOptions = mutateExecOptions;\n\nvar existsSync = fs.existsSync || path.existsSync;\n\nfunction findAppScript() {\n  // nodemon has been run alone, so try to read the package file\n  // or try to read the index.js file\n\n  var pkg =\n    existsSync(path.join(process.cwd(), 'package.json')) &&\n    require(path.join(process.cwd(), 'package.json'));\n  if ((!pkg || pkg.main == undefined) && existsSync('./index.js')) {\n    return 'index.js';\n  }\n}\n\n/**\n * Load the nodemon config, first reading the global root/nodemon.json, then\n * the local nodemon.json to the exec and then overwriting using any user\n * specified settings (i.e. from the cli)\n *\n * @param  {Object} settings user defined settings\n * @param  {Function} ready    callback that receives complete config\n */\nfunction load(settings, options, config, callback) {\n  config.loaded = [];\n  // first load the root nodemon.json\n  loadFile(options, config, utils.home, function (options) {\n    // then load the user's local configuration file\n    if (settings.configFile) {\n      options.configFile = path.resolve(settings.configFile);\n    }\n    loadFile(options, config, process.cwd(), function (options) {\n      // Then merge over with the user settings (parsed from the cli).\n      // Note that merge protects and favours existing values over new values,\n      // and thus command line arguments get priority\n      options = utils.merge(settings, options);\n\n      // legacy support\n      if (!Array.isArray(options.ignore)) {\n        options.ignore = [options.ignore];\n      }\n\n      if (!options.ignoreRoot) {\n        options.ignoreRoot = defaults.ignoreRoot;\n      }\n\n      // blend the user ignore and the default ignore together\n      if (options.ignoreRoot && options.ignore) {\n        if (!Array.isArray(options.ignoreRoot)) {\n          options.ignoreRoot = [options.ignoreRoot];\n        }\n        options.ignore = options.ignoreRoot.concat(options.ignore);\n      } else {\n        options.ignore = defaults.ignore.concat(options.ignore);\n      }\n\n      // add in any missing defaults\n      options = utils.merge(options, defaults);\n\n      if (!options.script && !options.exec) {\n        var found = findAppScript();\n        if (found) {\n          if (!options.args) {\n            options.args = [];\n          }\n          // if the script is found as a result of not being on the command\n          // line, then we move any of the pre double-dash args in execArgs\n          const n =\n            options.scriptPosition === null\n              ? options.args.length\n              : options.scriptPosition;\n\n          options.execArgs = (options.execArgs || []).concat(\n            options.args.splice(0, n)\n          );\n          options.scriptPosition = null;\n\n          options.script = found;\n        }\n      }\n\n      mutateExecOptions(options);\n\n      if (options.quiet) {\n        utils.quiet();\n      }\n\n      if (options.verbose) {\n        utils.debug = true;\n      }\n\n      // simplify the ready callback to be called after the rules are normalised\n      // from strings to regexp through the rules lib. Note that this gets\n      // created *after* options is overwritten twice in the lines above.\n      var ready = function (options) {\n        normaliseRules(options, callback);\n      };\n\n      ready(options);\n    });\n  });\n}\n\nfunction normaliseRules(options, ready) {\n  // convert ignore and watch options to rules/regexp\n  rules.watch.add(options.watch);\n  rules.ignore.add(options.ignore);\n\n  // normalise the watch and ignore arrays\n  options.watch = options.watch === false ? false : rules.rules.watch;\n  options.ignore = rules.rules.ignore;\n\n  ready(options);\n}\n\n/**\n * Looks for a config in the current working directory, and a config in the\n * user's home directory, merging the two together, giving priority to local\n * config. This can then be overwritten later by command line arguments\n *\n * @param  {Function} ready callback to pass loaded settings to\n */\nfunction loadFile(options, config, dir, ready) {\n  if (!ready) {\n    ready = function () {};\n  }\n\n  var callback = function (settings) {\n    // prefer the local nodemon.json and fill in missing items using\n    // the global options\n    ready(utils.merge(settings, options));\n  };\n\n  if (!dir) {\n    return callback({});\n  }\n\n  var filename = options.configFile || path.join(dir, 'nodemon.json');\n\n  if (config.loaded.indexOf(filename) !== -1) {\n    // don't bother re-parsing the same config file\n    return callback({});\n  }\n\n  fs.readFile(filename, 'utf8', function (err, data) {\n    if (err) {\n      if (err.code === 'ENOENT') {\n        if (!options.configFile && dir !== utils.home) {\n          // if no specified local config file and local nodemon.json\n          // doesn't exist, try the package.json\n          return loadPackageJSON(config, callback);\n        }\n      }\n      return callback({});\n    }\n\n    var settings = {};\n\n    try {\n      settings = JSON.parse(data.toString('utf8').replace(/^\\uFEFF/, ''));\n      if (!filename.endsWith('package.json') || settings.nodemonConfig) {\n        config.loaded.push(filename);\n      }\n    } catch (e) {\n      utils.log.fail('Failed to parse config ' + filename);\n      console.error(e);\n      process.exit(1);\n    }\n\n    // options values will overwrite settings\n    callback(settings);\n  });\n}\n\nfunction loadPackageJSON(config, ready) {\n  if (!ready) {\n    ready = () => {};\n  }\n\n  const dir = process.cwd();\n  const filename = path.join(dir, 'package.json');\n  const packageLoadOptions = { configFile: filename };\n  return loadFile(packageLoadOptions, config, dir, (settings) => {\n    ready(settings.nodemonConfig || {});\n  });\n}\n\nfunction mutateExecOptions(options) {\n  // work out the execOptions based on the final config we have\n  options.execOptions = exec(\n    {\n      script: options.script,\n      exec: options.exec,\n      args: options.args,\n      scriptPosition: options.scriptPosition,\n      nodeArgs: options.nodeArgs,\n      execArgs: options.execArgs,\n      ext: options.ext,\n      env: options.env,\n    },\n    options.execMap\n  );\n\n  // clean up values that we don't need at the top level\n  delete options.scriptPosition;\n  delete options.script;\n  delete options.args;\n  delete options.ext;\n\n  return options;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}